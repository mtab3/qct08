#include "MainWindow.h"

void MainWindow::AnsIsBusy( SMsg msg )
{
  if ( ( msg.ToCh() == "" ) || ( ! AxName2Num.contains( msg.ToCh() ) ) ){
    s->SendAns( msg.To(), msg.From(), "@IsBusy Er:" );
  } else {
    A->SendCMD( msg, QString( "STR%1" ).arg( AxName2Num[ msg.ToCh() ] ), "" );
  }
}

void MainWindow::AnsGetValue( SMsg msg )
{
  if ( ( msg.ToCh() == "" ) || ( ! AxName2Num.contains( msg.ToCh() ) ) ){
    s->SendAns( msg.To(), msg.From(), "@GetValue Er:" );
  } else {
    A->SendCMD( msg, QString( "RDP%1" ).arg( AxName2Num[ msg.ToCh() ] ), "" );
  }
}

void MainWindow::AnsSetValue( SMsg msg )
{
  QString SCMD, ACMD;
  if ( msg.Msgt() == SETVALUE ) {
    SCMD = "SetValue";
    ACMD = "APS";
  } else {
    SCMD = "SetValueREL";
    ACMD = "RPS";
  }

  if ( !Standby ) {   // 通常の各軸個別駆動
    if ( ( msg.ToCh() == "" ) || ( ! AxName2Num.contains( msg.ToCh() ) ) || ( msg.Vals().count() != 2 ) ){
      s->SendAns( msg.To(), msg.From(), QString( "@%1 Er:" ).arg( SCMD ) );
    } else {
      int ch = AxName2Num[ msg.ToCh() ];
      int point = msg.Vals()[1].toInt();
      if (  ! A->isBusy( ch ) ) {
        s->SendEvent( msg.To(), QString( "_ChangedIsBusy 1" ) );                    // とにかく busy のイベント発生
        s->SendAns( msg.To(), msg.From(), QString( "@%1 %2 Ok:" ).arg( SCMD ).arg( point ) ); // とにかく OK の返事だけ返しておく
        A->SendCMD( msg,
                    QString( "%1%2" ).arg( ACMD ).arg( ch ),
                    QString( "/%2/%3/%4" ).arg( VTableNo[ch] ).arg( point ).arg( 0 ) );
      } else {
        s->SendAns( msg.To(), msg.From(), QString( "@%1 %2 Er: Busy" ).arg( SCMD ).arg( point ) );
      }
    }
  } else {  // Standby / SyncRun を使った多軸同時駆動
    if ( ( msg.ToCh() == "" ) || ( ! AxName2Num.contains( msg.ToCh() ) ) || ( msg.Vals().count() != 2 ) ){
      s->SendAns( msg.To(), msg.From(), QString( "@%1 Er:" ).arg( SCMD ) );
    } else {
      int ch = AxName2Num[ msg.ToCh() ];
      int point = msg.Vals()[1].toInt();
      if ( StandbyAxes < MaxSyncAxes ) {
        StandbyTable[ StandbyAxes ].ax = ch;
        StandbyTable[ StandbyAxes ].relabs = ( msg.Msgt() == SETVALUE ) ? ABS : REL;
        StandbyTable[ StandbyAxes ].speed = VTableNo[ ch ];
        StandbyTable[ StandbyAxes ].point = point;
        StandbyAxes++;
      } else {
        s->SendAns( msg.To(), msg.From(), QString( "@%1 Er: Too Many Standby Axes" ).arg( SCMD ) );
      }
    }
  }
}

void MainWindow::AnsGetSpeedSelected( SMsg msg )
{
  if ( ( msg.ToCh() == "" ) || ( ! AxName2Num.contains( msg.ToCh() ) ) ){
    s->SendAns( msg.To(), msg.From(), QString( "@%1 Er:" ).arg( msg.Msg() ) );
  } else {
    int ch = AxName2Num[ msg.ToCh() ];
    QString speed = "H";
    if ( VTableNo[ ch ] == LOW ) { speed = "L"; }
    else if ( VTableNo[ ch ] == MIDDLE ) { speed = "M"; }
    else if ( VTableNo[ ch ] == HIGH ) { speed = "H"; }
    else { speed = QString::number( VTableNo[ ch ] ); }
    s->SendAns( msg.To(), msg.From(), QString( "@%1 %2" ).arg( msg.Msg() ).arg( speed ) );
  }
}

void MainWindow::AnsSelectSpeed( SMsg msg )
{
  if ( ( msg.ToCh() == "" ) || ( ! AxName2Num.contains( msg.ToCh() ) ) ){
    s->SendAns( msg.To(), msg.From(), QString( "@%1 Er:" ).arg( msg.Msg() ) );
  } else {
    int ch = AxName2Num[ msg.ToCh() ];
    int speed = 0;
    if ( msg.Msg() == "SpeedHigh" ) { speed = HIGH; }
    else if ( msg.Msg() == "SpeedMiddle" ) { speed = MIDDLE; }
    else if ( msg.Msg() == "SpeedLow" ) { speed = LOW; }
    VTableNo[ ch ] = speed;
    s->SendAns( msg.To(), msg.From(), QString( "@%1 Ok:" ).arg( msg.Msg() ) );
  }
}

void MainWindow::AnsStop( SMsg msg )
{
  if ( msg.ToCh() == "" ) {
    A->SendCMD( msg, QString( "STP%1" ).arg( 0 ), "/0" );   // ch = 0 : は全チャンネル指定
  } else if ( ! AxName2Num.contains( msg.ToCh() ) ){
    s->SendAns( msg.To(), msg.From(), QString( "@%1 Er:" ).arg( msg.Msg() ) );
  } else {
    int ch = AxName2Num[ msg.ToCh() ];
    A->SendCMD( msg, QString( "STP%1" ).arg( ch ), "/0" );
  }
}

void MainWindow::AnsRemote( SMsg msg )
{
  // 常に無条件で Ok:
  s->SendAns( msg.To(), msg.From(), QString( "@%1 Ok:" ).arg( msg.Msg() ) );
}

void MainWindow::AnsStopEmergency( SMsg msg )
{
  if ( msg.ToCh() == "" ) {
    A->SendCMD( msg, QString( "STP%1" ).arg( 0 ), "/1" );   // ch = 0 : は全チャンネル指定
  } else if ( ! AxName2Num.contains( msg.ToCh() ) ){
    s->SendAns( msg.To(), msg.From(), QString( "@%1 Er:" ).arg( msg.Msg() ) );
  } else {
    int ch = AxName2Num[ msg.ToCh() ];
    A->SendCMD( msg, QString( "STP%1" ).arg( ch ), "/1" );
  }
}

void MainWindow::AnsStandby( SMsg msg )
{
  if (( SyncRunning )||( Standby )) {
    s->SendAns( msg.To(), msg.From(), QString( "@%1 Er: in Standby/SyncRun" ).arg( msg.Msg() ) );
  }
  Standby = true;
  // これが true になると、SetValue, SetValueREL 等で直接 ARIES を駆動しないようになる
  StandbyAxes = 0;

  // 常に無条件で Ok:
  s->SendAns( msg.To(), msg.From(), QString( "@%1 Ok:" ).arg( msg.Msg() ) );
}

void MainWindow::AnsSyncRun( SMsg msg )
{
  if (( SyncRunning )||( ! Standby )) {
    s->SendAns( msg.To(), msg.From(),
                QString( "@%1 Er: Has not Standby " ).arg( msg.Msg() ) );
    return;
  }
  if (( StandbyAxes <= 0 )||( StandbyAxes > MaxSyncAxes )) {
    s->SendAns( msg.To(), msg.From(),
                QString( "@%1 Er: Number of Standby axes (%2) are invalid " )
                .arg( msg.Msg() ).arg( StandbyAxes ) );
    return;
  }
  // とにかく OK の返事だけ返しておく
  s->SendAns( msg.To(), msg.From(), QString( "@%1 Ok:" ).arg( msg.Msg() ) );

  QString cmd0 = QString( "MPS" );
  for ( int i = 0; i < StandbyAxes; i++ ) {
    QString preCmd = QString( "MPI%1/%2" ).arg( i + 1 ).arg( StandbyTable[i].ax );
    QString prePrm = QString( "/%1/%2" ).arg( StandbyTable[i].relabs ).arg( StandbyTable[i].speed );
    A->SendCMD( msg, preCmd, prePrm );

    // とにかく busy のイベント発生
    QString StarsTo = QString( "%1.%2" ).arg( msg.ToDev() ).arg( AxNum2Name[ StandbyTable[i].ax ] );
    s->SendEvent( StarsTo, QString( "_ChangedIsBusy 1" ) );
    cmd0 += QString( "%1/%2/" ).arg( i + 1 ).arg( StandbyTable[i].point );
  }
  cmd0 += "0";
  int i1 = cmd0.indexOf( "/" );
  QString cmd = cmd0.left( i1 );
  QString prm = cmd0.mid( i1 );
  A->SendCMD( msg, cmd, prm );

  SyncRunning = true;
  Standby = false;
}

void MainWindow::AnsSetSpeed( SMsg msg )     // 現状、設定できる最低スピードは 3pps
{
  if ( ! AxName2Num.contains( msg.ToCh() ) ) {
    s->SendAns( msg.To(), msg.From(),
                QString( "@%1 Er: unknown channel name" ).arg( msg.Msg() ) );
    return;
  }
  if ( msg.Vals().count() <= 1 ) {
    s->SendAns( msg.To(), msg.From(),
                QString( "@%1 Er: missing parameters" ).arg( msg.Msg() ) );
    return;
  }
  int ch = AxName2Num[ msg.ToCh() ];

  /** テーブル書き込み動作 **/
  if ( msg.Msg() == "SetHighSpeed" ) {
    A->SetSpeed( msg, ch, HIGH, msg.Vals()[1].toInt() );
  } else if ( msg.Msg() == "SetMiddleSpeed" ) {
    A->SetSpeed( msg, ch, MIDDLE, msg.Vals()[1].toInt() );
  } else if ( msg.Msg() == "SetLowSpeed" ) {
    A->SetSpeed( msg, ch, LOW, msg.Vals()[1].toInt() );
  }
}

void MainWindow::ParseAns( SMsg smsg, AMsg amsg )
{
  ShowMsg( amsg.msg() );

  if ( amsg.cmd() == "MPI" ) {// MPI に対応するアクションは無い
    return;
  }

  QString ans = QString( "@%1 " ).arg( smsg.Msg() );
  if ( amsg.stat() == QString( "E" ) ) {  // ARIES からの返答はエラーだった
    if ( smsg.Msgt() != NOTMSG ) {
      s->SendCMD( smsg.From(), ans + "Er:" );
    }
  } else {                    // ARIES からの返答は正常終了だった
    switch( smsg.Msgt() ) {
      // 値を返す定形の返答
    case ISBUSY:
    case GETVALUE:
      s->SendAns( smsg.To(), smsg.From(), QString( "%1%2" ).arg( ans ).arg( amsg.val() ) );
      break;

      // Ok: を返す定形の返答
    case STOP:
    case STOPEMERGENCY:
    case SETHIGHSPEED:
    case SETMIDDLESPEED:
    case SETLOWSPEED:
      s->SendAns( smsg.To(), smsg.From(), QString( "%1Ok:" ).arg( ans ) );
      break;

      // 返答はすでに終わっていて、ビジーのフラグをはずすだけの返答
    case SETVALUE:
    case SETVALUEREL:
      s->SendEvent( smsg.To(), QString( "_ChangedIsBusy 0" ) );
      break;

      // 返答はすでに終わっていて、ビジーフラグをはずだけだが、関連するチャンネル全部に通知しないといけない
    case SYNCRUN:
      for ( int i = 0; i < StandbyAxes; i++ ) {
        s->SendEvent( QString( "%1.%2" ).arg(smsg.ToDev()).arg(AxNum2Name[StandbyTable[i].ax]),
            "_ChangedIsBusy 0" );
      }
      SyncRunning = false;
      break;

      // 以下のコマンドは ARIES と通信せずに完結している
    case GETSPEEDSELECTED:
    case SPEEDHIGH:
    case SPEEDMIDDLE:
    case SPEEDLOW:
    case REMOTE:
    case STANDBY:
      break;

      // 以下のメッセージは内部で発生させるもので Stars からは来ない
    case INTERNALMSG:
      s->SendEvent( smsg.To(), QString( "_ChangedValue %1" ).arg( amsg.val() ) );
      break;
    case INARIES:
    case NOTMSG:
      break;
  //default: // あえて、default をなくしてエラーチェックを厳しくする
    }
  }
}
